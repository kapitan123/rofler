// it is a wrapper around application to format requests
package port

import (
	"encoding/base64"
	"encoding/json"
	"net/http"

	"github.com/go-chi/render"
	"github.com/kapitan123/telegrofler/common/server/httperr"
	"github.com/kapitan123/telegrofler/service/downloader/app"
	"github.com/sirupsen/logrus"
)

// implements interface generated by openapi spec
type HttpServer struct {
	app app.Application
}

func NewHttpServer(app app.Application) HttpServer {
	return HttpServer{app: app}
}

func (h HttpServer) HandleVideoUrlPublishedMessage(w http.ResponseWriter, r *http.Request) {
	postMessage := PostPubSubMessage{}
	if err := json.NewDecoder(r.Body).Decode(&postMessage); err != nil {
		httperr.BadRequest("invalid format of pubsub message", err, w, r)
		return
	}

	LogBody(postMessage)

	var videoMessage VideoUrlPublishedMessage

	decodedDataBytes, err := base64.StdEncoding.DecodeString(postMessage.Data)
	if err != nil {
		httperr.BadRequest("invalid encoding of pubsub data", err, w, r)
		return
	}

	err = json.Unmarshal(decodedDataBytes, &videoMessage)
	if err != nil {
		httperr.BadRequest("invalid pubsub.Data payload", err, w, r)
		return
	}

	err = h.app.SaveVideoToStorage(r.Context(), videoMessage.Url)

	if err != nil {
		httperr.RespondWithSlugError(err, w, r)
		return
	}

	render.Status(r, 200)
}

type VideoUrlPublishedMessage struct {
	Url string `json:"url"`
}

// AK TODO temp logging
func LogBody(upd PostPubSubMessage) {
	log := logrus.WithField("data:", string(upd.Data)).WithField("messageid", upd.MessageId)

	log.Info("pubsub message recieved")
}
